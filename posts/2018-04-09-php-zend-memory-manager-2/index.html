<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>PHP内存管理ZMM（三）－内存分配函数emalloc | Petrie's Site</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="主流程
emalloc是ZMM中heap层实现的函数，其内部调用_zend_mm_alloc_int函数。在_zend_mm_alloc_int中会依次在heap层的缓存区、小内存区、大内存区、剩余内存区寻找合适的内存。如果在这四个区域中都为查找到合适的内存，则调用malloc向内核申请，在向内核申请内存时，申请的大小必须是segment_size(256k)的整数倍，最小为256k。以下用流程图展示"><meta name=generator content="Hugo 0.99.1"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="PHP内存管理ZMM（三）－内存分配函数emalloc"><meta property="og:description" content="主流程
emalloc是ZMM中heap层实现的函数，其内部调用_zend_mm_alloc_int函数。在_zend_mm_alloc_int中会依次在heap层的缓存区、小内存区、大内存区、剩余内存区寻找合适的内存。如果在这四个区域中都为查找到合适的内存，则调用malloc向内核申请，在向内核申请内存时，申请的大小必须是segment_size(256k)的整数倍，最小为256k。以下用流程图展示"><meta property="og:type" content="article"><meta property="og:url" content="https://petrie.github.io/posts/2018-04-09-php-zend-memory-manager-2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-11T10:22:53+00:00"><meta property="article:modified_time" content="2018-04-11T10:22:53+00:00"><meta itemprop=name content="PHP内存管理ZMM（三）－内存分配函数emalloc"><meta itemprop=description content="主流程
emalloc是ZMM中heap层实现的函数，其内部调用_zend_mm_alloc_int函数。在_zend_mm_alloc_int中会依次在heap层的缓存区、小内存区、大内存区、剩余内存区寻找合适的内存。如果在这四个区域中都为查找到合适的内存，则调用malloc向内核申请，在向内核申请内存时，申请的大小必须是segment_size(256k)的整数倍，最小为256k。以下用流程图展示"><meta itemprop=datePublished content="2018-04-11T10:22:53+00:00"><meta itemprop=dateModified content="2018-04-11T10:22:53+00:00"><meta itemprop=wordCount content="599"><meta itemprop=keywords content="php,c,"><meta name=twitter:card content="summary"><meta name=twitter:title content="PHP内存管理ZMM（三）－内存分配函数emalloc"><meta name=twitter:description content="主流程
emalloc是ZMM中heap层实现的函数，其内部调用_zend_mm_alloc_int函数。在_zend_mm_alloc_int中会依次在heap层的缓存区、小内存区、大内存区、剩余内存区寻找合适的内存。如果在这四个区域中都为查找到合适的内存，则调用malloc向内核申请，在向内核申请内存时，申请的大小必须是segment_size(256k)的整数倍，最小为256k。以下用流程图展示"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-T6WSQ8M692"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-T6WSQ8M692",{anonymize_ip:!1})}</script></head></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Petrie's Site</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">PHP内存管理ZMM（三）－内存分配函数emalloc</h1><time class="f6 mv4 dib tracked" datetime=2018-04-11T10:22:53Z>April 11, 2018</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h4 id=主流程>主流程</h4><p>emalloc是ZMM中heap层实现的函数，其内部调用_zend_mm_alloc_int函数。在_zend_mm_alloc_int中会依次在heap层的缓存区、小内存区、大内存区、剩余内存区寻找合适的内存。如果在这四个区域中都为查找到合适的内存，则调用malloc向内核申请，在向内核申请内存时，申请的大小必须是segment_size(256k)的整数倍，最小为256k。以下用流程图展示</p><pre tabindex=0><code class=language-flow data-lang=flow>st=&gt;start:   Start   |past:&gt;http://www.google.com[blank]
e=&gt;end: End:&gt;http://www.google.com
op1=&gt;operation: My Operation|past
op2=&gt;operation: Stuff|current
sub1=&gt;subroutine: My Subroutine|invalid
cond=&gt;condition: Yes or No?|approved:&gt;http://www.google.com
c2=&gt;condition: Good idea|rejected
io=&gt;inputoutput: catch something...|request
cache=&gt;operation: 查找缓存 heap- &gt;cache 
找到返回，未找到则继续|past
free_buckets=&gt;operation: 查找小块内存heap- &gt;free_buckets 
找到返回，未找到则继续|past
large_free_buckets=&gt;operation: 查找大块内存heap- &gt;large_free_buckets 
找到返回，未找到则继续|past
rest_buckets=&gt;operation: 查找剩余内存 heap- &gt;rest_buckets 
找到返回，未找到则继续|past
core_malloc=&gt;operation: 在heap四个区域中均为找到合适大小的内存，
则向内核申请内存
add_rest=&gt;operation: 将内核申请的内存分割为两部分，一部分函数返回，即本次申请的内存。
剩下的调用zend_mm_add_to_free_list，根据大小添加到heap的四个区域中
st-&gt;cache-&gt;free_buckets-&gt;large_free_buckets-&gt;rest_buckets-&gt;core_malloc-&gt;add_rest-&gt;e
</code></pre><h4 id=代码注解>代码注解</h4><p>代码如下：<a href=https://github.com/php/php-src/blob/9c1d686748cdb46e2f80a9bc800df0015fb709b1/Zend/zend_alloc.c#L1880>引自</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_zend_mm_alloc_int</span>(zend_mm_heap <span style=color:#f92672>*</span>heap, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   zend_mm_free_block <span style=color:#f92672>*</span>best_fit;
</span></span><span style=display:flex><span>  <span style=color:#75715e>//计算true_size,对于计算逻辑和取值可以参考上一篇文章
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   size_t true_size <span style=color:#f92672>=</span> ZEND_MM_TRUE_SIZE(size);
</span></span><span style=display:flex><span>   size_t block_size;
</span></span><span style=display:flex><span>   size_t remaining_size;
</span></span><span style=display:flex><span>   size_t segment_size;
</span></span><span style=display:flex><span>   zend_mm_segment <span style=color:#f92672>*</span>segment;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> keep_rest <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef ZEND_SIGNALS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   TSRMLS_FETCH();
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>   HANDLE_BLOCK_INTERRUPTIONS();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (EXPECTED((true_size))) {
</span></span><span style=display:flex><span>     <span style=color:#75715e>//根据true_size 计算 index的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      size_t index <span style=color:#f92672>=</span> ZEND_MM_BUCKET_INDEX(true_size);
</span></span><span style=display:flex><span>      size_t bitmap;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (UNEXPECTED(true_size <span style=color:#f92672>&lt;</span> size)) {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>goto</span> out_of_memory;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_MM_CACHE </span><span style=color:#75715e>//在缓存块中中查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (EXPECTED(heap<span style=color:#f92672>-&gt;</span>cache[index] <span style=color:#f92672>!=</span> NULL)) {
</span></span><span style=display:flex><span>         <span style=color:#75715e>/* Get block from cache */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_MM_CACHE_STAT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         heap<span style=color:#f92672>-&gt;</span>cache_stat[index].count<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>         heap<span style=color:#f92672>-&gt;</span>cache_stat[index].hit<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         best_fit <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>cache[index];
</span></span><span style=display:flex><span>         heap<span style=color:#f92672>-&gt;</span>cache[index] <span style=color:#f92672>=</span> best_fit<span style=color:#f92672>-&gt;</span>prev_free_block;
</span></span><span style=display:flex><span>         heap<span style=color:#f92672>-&gt;</span>cached <span style=color:#f92672>-=</span> true_size;
</span></span><span style=display:flex><span>         ZEND_MM_CHECK_MAGIC(best_fit, MEM_BLOCK_CACHED);
</span></span><span style=display:flex><span>         ZEND_MM_SET_DEBUG_INFO(best_fit, size, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>         HANDLE_UNBLOCK_INTERRUPTIONS();
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>return</span> ZEND_MM_DATA_OF(best_fit);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_MM_CACHE_STAT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      heap<span style=color:#f92672>-&gt;</span>cache_stat[index].miss<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	 <span style=color:#75715e>//在小内存块中查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      bitmap <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>free_bitmap <span style=color:#f92672>&gt;&gt;</span> index;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (bitmap) { <span style=color:#75715e>//如果bitmap不等于0，说明存在大于或等于true_size的内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>/* Found some &#34;small&#34; free block that can be used */</span>
</span></span><span style=display:flex><span>         index <span style=color:#f92672>+=</span> zend_mm_low_bit(bitmap);<span style=color:#75715e>//定位到true_size所在的index。举例说明：假设heap-&gt;free_bitmap＝0b100010, index=3,则bitmap＝(0b100),zend_mm_low_bit(bitmap)=3,最终index＝6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         best_fit <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>free_buckets[index<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>];<span style=color:#75715e>//从free_buckets取出内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#if ZEND_MM_CACHE_STAT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         heap<span style=color:#f92672>-&gt;</span>cache_stat[ZEND_MM_NUM_BUCKETS].hit<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#66d9ef>goto</span> zend_mm_finished_searching_for_block; <span style=color:#75715e>//内存查找完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_MM_CACHE_STAT
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   heap<span style=color:#f92672>-&gt;</span>cache_stat[ZEND_MM_NUM_BUCKETS].miss<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>//从大内存中查找，这部分逻辑，后续文章会写
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   best_fit <span style=color:#f92672>=</span> zend_mm_search_large_block(heap, true_size);
</span></span><span style=display:flex><span>   <span style=color:#75715e>//如果大内存中也没有找到，且real_size已经超过php内存限制，则到剩余内存中查找
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>best_fit <span style=color:#f92672>&amp;&amp;</span> heap<span style=color:#f92672>-&gt;</span>real_size <span style=color:#f92672>&gt;=</span> heap<span style=color:#f92672>-&gt;</span>limit <span style=color:#f92672>-</span> heap<span style=color:#f92672>-&gt;</span>block_size) {
</span></span><span style=display:flex><span>      zend_mm_free_block <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>rest_buckets[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>      size_t best_size <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>   <span style=color:#75715e>//取头节点并循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>!=</span> ZEND_MM_REST_BUCKET(heap)) {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>if</span> (UNEXPECTED(ZEND_MM_FREE_BLOCK_SIZE(p) <span style=color:#f92672>==</span> true_size)) {
</span></span><span style=display:flex><span>            best_fit <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> zend_mm_finished_searching_for_block;
</span></span><span style=display:flex><span>         } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (ZEND_MM_FREE_BLOCK_SIZE(p) <span style=color:#f92672>&gt;</span> true_size <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                    ZEND_MM_FREE_BLOCK_SIZE(p) <span style=color:#f92672>&lt;</span> best_size) {
</span></span><span style=display:flex><span>            best_size <span style=color:#f92672>=</span> ZEND_MM_FREE_BLOCK_SIZE(p);
</span></span><span style=display:flex><span>            best_fit <span style=color:#f92672>=</span> p;
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>         p <span style=color:#f92672>=</span> p<span style=color:#f92672>-&gt;</span>prev_free_block;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#75715e>//以上四个区域均未找到
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>best_fit) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (true_size <span style=color:#f92672>&gt;</span> heap<span style=color:#f92672>-&gt;</span>block_size <span style=color:#f92672>-</span> (ZEND_MM_ALIGNED_SEGMENT_SIZE <span style=color:#f92672>+</span> ZEND_MM_ALIGNED_HEADER_SIZE)) {<span style=color:#75715e>//true_size是否大于segment_size(block_size)，小于，则申请segment_size，大于则申请小于true_size的segment_size的整数位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#75715e>/* Make sure we add a memory block which is big enough,
</span></span></span><span style=display:flex><span><span style=color:#75715e>            segment must have header &#34;size&#34; and trailer &#34;guard&#34; block */</span>
</span></span><span style=display:flex><span>         segment_size <span style=color:#f92672>=</span> true_size <span style=color:#f92672>+</span> ZEND_MM_ALIGNED_SEGMENT_SIZE <span style=color:#f92672>+</span> ZEND_MM_ALIGNED_HEADER_SIZE;
</span></span><span style=display:flex><span>         segment_size <span style=color:#f92672>=</span> (segment_size <span style=color:#f92672>+</span> (heap<span style=color:#f92672>-&gt;</span>block_size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(heap<span style=color:#f92672>-&gt;</span>block_size<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>         keep_rest <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#75715e>//如果keep_rest为1，则在后续处理剩余空闲内存时，将其放入剩余内存区域。这里的考虑应该是，当前剩余空闲内存会比较大。而且也会情况也会比较少，所以单独处理放入剩余内存区域(rest_buckets)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>         segment_size <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>block_size;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>	  <span style=color:#75715e>//校验内存是否超出限制
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (segment_size <span style=color:#f92672>&lt;</span> true_size <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>          heap<span style=color:#f92672>-&gt;</span>real_size <span style=color:#f92672>+</span> segment_size <span style=color:#f92672>&gt;</span> heap<span style=color:#f92672>-&gt;</span>limit) {
</span></span><span style=display:flex><span>         <span style=color:#75715e>/* Memory limit overflow */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_MM_CACHE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         zend_mm_free_cache(heap);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         HANDLE_UNBLOCK_INTERRUPTIONS();
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         zend_mm_safe_error(heap, <span style=color:#e6db74>&#34;Allowed memory size of %ld bytes exhausted at %s:%d (tried to allocate %lu bytes)&#34;</span>, heap<span style=color:#f92672>-&gt;</span>limit, __zend_filename, __zend_lineno, size);
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         zend_mm_safe_error(heap, <span style=color:#e6db74>&#34;Allowed memory size of %ld bytes exhausted (tried to allocate %lu bytes)&#34;</span>, heap<span style=color:#f92672>-&gt;</span>limit, size);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      }
</span></span><span style=display:flex><span>	 <span style=color:#75715e>//向系统申请内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      segment <span style=color:#f92672>=</span> (zend_mm_segment <span style=color:#f92672>*</span>) ZEND_MM_STORAGE_ALLOC(segment_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>segment) {
</span></span><span style=display:flex><span>         <span style=color:#75715e>/* Storage manager cannot allocate memory */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_MM_CACHE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         zend_mm_free_cache(heap);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>out_of_memory:
</span></span><span style=display:flex><span>         HANDLE_UNBLOCK_INTERRUPTIONS();
</span></span><span style=display:flex><span><span style=color:#75715e>#if ZEND_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         zend_mm_safe_error(heap, <span style=color:#e6db74>&#34;Out of memory (allocated %ld) at %s:%d (tried to allocate %lu bytes)&#34;</span>, heap<span style=color:#f92672>-&gt;</span>real_size, __zend_filename, __zend_lineno, size);
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         zend_mm_safe_error(heap, <span style=color:#e6db74>&#34;Out of memory (allocated %ld) (tried to allocate %lu bytes)&#34;</span>, heap<span style=color:#f92672>-&gt;</span>real_size, size);
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#75715e>//更新heap统计字段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      heap<span style=color:#f92672>-&gt;</span>real_size <span style=color:#f92672>+=</span> segment_size;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (heap<span style=color:#f92672>-&gt;</span>real_size <span style=color:#f92672>&gt;</span> heap<span style=color:#f92672>-&gt;</span>real_peak) {
</span></span><span style=display:flex><span>         heap<span style=color:#f92672>-&gt;</span>real_peak <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>real_size;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      segment<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> segment_size;
</span></span><span style=display:flex><span>      segment<span style=color:#f92672>-&gt;</span>next_segment <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>segments_list;
</span></span><span style=display:flex><span>      heap<span style=color:#f92672>-&gt;</span>segments_list <span style=color:#f92672>=</span> segment;
</span></span><span style=display:flex><span>      <span style=color:#75715e>//格式化申请的内存 为zend_mm_free_block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      best_fit <span style=color:#f92672>=</span> (zend_mm_free_block <span style=color:#f92672>*</span>) ((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) segment <span style=color:#f92672>+</span> ZEND_MM_ALIGNED_SEGMENT_SIZE);
</span></span><span style=display:flex><span>      ZEND_MM_MARK_FIRST_BLOCK(best_fit);<span style=color:#75715e>//初始化block中prev字段
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	  <span style=color:#75715e>//这里最后的ZEND_MM_ALIGNED_HEADER_SIZE是预留在最后的remaining_size使用的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      block_size <span style=color:#f92672>=</span> segment_size <span style=color:#f92672>-</span> ZEND_MM_ALIGNED_SEGMENT_SIZE <span style=color:#f92672>-</span> ZEND_MM_ALIGNED_HEADER_SIZE;
</span></span><span style=display:flex><span>	  <span style=color:#75715e>//初始化新segment的能存末位的 zend_mm_block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      ZEND_MM_LAST_BLOCK(ZEND_MM_BLOCK_AT(best_fit, block_size));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>zend_mm_finished_searching_for_block:
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* remove from free list */</span>
</span></span><span style=display:flex><span>      ZEND_MM_CHECK_MAGIC(best_fit, MEM_BLOCK_FREED);
</span></span><span style=display:flex><span>      ZEND_MM_CHECK_COOKIE(best_fit);
</span></span><span style=display:flex><span>      ZEND_MM_CHECK_BLOCK_LINKAGE(best_fit);
</span></span><span style=display:flex><span>      zend_mm_remove_from_free_list(heap, best_fit);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      block_size <span style=color:#f92672>=</span> ZEND_MM_FREE_BLOCK_SIZE(best_fit);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#75715e>//计算使用后的剩余内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   remaining_size <span style=color:#f92672>=</span> block_size <span style=color:#f92672>-</span> true_size;
</span></span><span style=display:flex><span>   <span style=color:#75715e>//如果剩余内存小于block的头部大小，则将其合并到true_size中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> (remaining_size <span style=color:#f92672>&lt;</span> ZEND_MM_ALIGNED_MIN_HEADER_SIZE) {
</span></span><span style=display:flex><span>      true_size <span style=color:#f92672>=</span> block_size;
</span></span><span style=display:flex><span>      ZEND_MM_BLOCK(best_fit, ZEND_MM_USED_BLOCK, true_size);
</span></span><span style=display:flex><span>   } <span style=color:#66d9ef>else</span> {<span style=color:#75715e>//否则，将剩余内存放入到heap中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      zend_mm_free_block <span style=color:#f92672>*</span>new_free_block;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* prepare new free block */</span> 
</span></span><span style=display:flex><span>      ZEND_MM_BLOCK(best_fit, ZEND_MM_USED_BLOCK, true_size);
</span></span><span style=display:flex><span>      new_free_block <span style=color:#f92672>=</span> (zend_mm_free_block <span style=color:#f92672>*</span>) ZEND_MM_BLOCK_AT(best_fit, true_size);<span style=color:#75715e>//定位并格式化剩下的空闲内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      ZEND_MM_BLOCK(new_free_block, ZEND_MM_FREE_BLOCK, remaining_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* add the new free block to the free list */</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (EXPECTED(<span style=color:#f92672>!</span>keep_rest)) {<span style=color:#75715e>//这里请看上面代码中对keep_rest赋值时的解释
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         zend_mm_add_to_free_list(heap, new_free_block);
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>         zend_mm_add_to_rest_list(heap, new_free_block);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   ZEND_MM_SET_DEBUG_INFO(best_fit, size, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   heap<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>+=</span> true_size;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (heap<span style=color:#f92672>-&gt;</span>peak <span style=color:#f92672>&lt;</span> heap<span style=color:#f92672>-&gt;</span>size) {
</span></span><span style=display:flex><span>      heap<span style=color:#f92672>-&gt;</span>peak <span style=color:#f92672>=</span> heap<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   HANDLE_UNBLOCK_INTERRUPTIONS();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> ZEND_MM_DATA_OF(best_fit);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上就是emalloc的所有逻辑了。</p><h4 id=四个内存区域的区分>四个内存区域的区分</h4><p>基于64位系统</p><ul><li><p>缓存区 cache</p><p>todo</p></li><li><p>小内存区 free_buckets</p><p>当申请的内存小于<strong>520b</strong>时候，放入小内存区。这个数字是怎么来的呢。</p><p>逆推：当申请520b内存是，其true_size内存为520b+16(ZEND_MM_ALIGNED_HEADER_SIZE)=536，那么其实是需要536b大小的内存的。这其中还包含占用32b的<code>zend_mm_small_free_block</code>结构体<code>zend_mm_small_free_block</code>大小是固定的，所以不计入index计算，所以小内存区最大存入504b的内存，将504b按照计算index的方式逆推即右移3为则为最大的index值63。</p><p>正推：又因为小内存数组的长度为64*2。这里要看成64组，所以小内存数组的index的最大值63＊2。</p><p>综上，因为小内存数组最大index为63（64位系统），所以其所能存储的最大值</p></li><li><p>大内存区 large_free_buckets</p><p>不满足<strong>小内存区</strong>条件和<strong>剩余内存</strong>条件的放入large_free_buckets</p></li><li><p>剩余内存区</p><p>当heap中没有合适大小的内存向内核申请时，如果申请的大小大于heap->block_size。则当有额外剩下的内存时，放入到<strong>剩余内存区rest_bucket</strong>。举个例子假设heap->block_size＝256k。如果emalloc申请的大小小于256k，则剩下的内存存入<strong>大内存区large_free_bucket</strong>，否则 emalloc 申请的大小大于256k时，则剩下的内存存入<strong>剩余内存区rest_buckets</strong>中</p></li></ul><ul class=pa0><li class="list di"><a href=/tags/php class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">php</a></li><li class="list di"><a href=/tags/c class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">c</a></li></ul><div class="mt6 instapaper_ignoref"><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//petrie.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/posts/2018-04-09-normal-zend-macro-value/>PHP内存管理ZMM（二）－常见宏的值</a></li><li class=mb2><a href=/posts/2018-03-29-first-php-extension/>PHP扩展开发－自动生成扩展骨架</a></li><li class=mb2><a href=/posts/2018-03-21-laravel-ioc/>如何独立的使用Laravel的IOC功能</a></li><li class=mb2><a href=/posts/2017-06-04-php-mysql-timeout/>PHP设置连接mysql超时时间</a></li><li class=mb2><a href=/posts/2017-04-10-mac-php-version/>更新Mac的PHP默认版本</a></li><li class=mb2><a href=/posts/2016-06-28-nignx-php%E4%B8%ADhttp%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E502/>Nignx+PHP中HTTP请求返回502</a></li><li class=mb2><a href=/posts/2015-03-05-ci-config/>CI 环境配置</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://petrie.github.io/>&copy; Petrie's Site 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>